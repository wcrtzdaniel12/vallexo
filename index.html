<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Memory Generator v2.6 - SERVICE ROLE FIX</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Inter:wght@300;400;500&family=JetBrains+Mono:wght@300;400&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <style>
    @keyframes glitch {
      0% { transform: translate(0); }
      20% { transform: translate(-2px, 2px); }
      40% { transform: translate(-2px, -2px); }
      60% { transform: translate(2px, 2px); }
      80% { transform: translate(2px, -2px); }
      100% { transform: translate(0); }
    }
    
    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }
    
    @keyframes scanline {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100vh); }
    }
    
    @keyframes ambient {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      50% { transform: translateY(-10px) rotate(0.5deg); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.6; }
    }
    
    .liminal-bg {
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 25%, #1f1f1f 50%, #2a2a2a 75%, #1a1a1a 100%);
      position: relative;
      overflow: hidden;
    }
    
    .liminal-bg::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 80%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(255, 255, 0, 0.05) 0%, transparent 50%);
      animation: ambient 20s ease-in-out infinite;
    }
    
    .glitch-text {
      animation: glitch 0.3s infinite;
      text-shadow: 
        2px 0 #00ffff,
        -2px 0 #ff00ff,
        0 2px #ffff00;
    }
    
    .flicker-text {
      animation: flicker 3s infinite;
    }
    
    .scanline {
      position: absolute;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.5), transparent);
      animation: scanline 8s linear infinite;
      pointer-events: none;
    }
    
    .glitch-button {
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .glitch-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.3), transparent);
      transition: left 0.5s ease;
    }
    
    .glitch-button:hover::before {
      left: 100%;
    }
    
    .glitch-button:hover {
      animation: glitch 0.1s infinite;
      box-shadow: 
        0 0 20px rgba(0, 255, 255, 0.5),
        0 0 40px rgba(255, 0, 255, 0.3);
    }
    
    .neon-pulse {
      animation: pulse 4s ease-in-out infinite;
    }
    
    .font-mono {
      font-family: 'JetBrains Mono', monospace;
    }
    
    .text-shadow-glow {
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }
    
    .brand-section {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 20px 0;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
      z-index: 100;
      transition: all 0.3s ease;
    }
    
    .brand-section.scrolled {
      background: rgba(0, 0, 0, 0.8);
      border-bottom: 1px solid rgba(0, 255, 255, 0.4);
    }
    
    .brand-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .brand-logo {
      font-family: 'JetBrains Mono', monospace;
      font-size: 24px;
      font-weight: 700;
      color: #00ffff;
      text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
      letter-spacing: 2px;
      animation: brand-glow 3s ease-in-out infinite;
    }
    
    .brand-tagline {
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
      font-weight: 300;
      letter-spacing: 1px;
      opacity: 0.8;
      animation: tagline-fade 4s ease-in-out infinite;
    }
    
    @keyframes brand-glow {
      0%, 100% { text-shadow: 0 0 15px rgba(0, 255, 255, 0.8); }
      50% { text-shadow: 0 0 25px rgba(0, 255, 255, 1), 0 0 35px rgba(0, 255, 255, 0.5); }
    }
    
    @keyframes tagline-fade {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 0.4; }
    }
    
    .brand-logo:hover {
      animation: brand-glitch 0.3s ease-in-out;
    }
    
    @keyframes brand-glitch {
      0% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      50% { transform: translateX(2px); }
      75% { transform: translateX(-1px); }
      100% { transform: translateX(0); }
    }
    
    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(20px);
      z-index: 1000;
      display: none;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    .modal-overlay.active {
      display: flex;
      opacity: 1;
    }
    
    .modal-content {
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 8px;
      padding: 40px;
      max-width: 500px;
      width: 90%;
      margin: auto;
      position: relative;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
      animation: modal-glow 3s ease-in-out infinite;
    }
    
    @keyframes modal-glow {
      0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.2); }
      50% { box-shadow: 0 0 50px rgba(0, 255, 255, 0.4); }
    }
    
    .modal-title {
      font-family: 'JetBrains Mono', monospace;
      font-size: 24px;
      color: #00ffff;
      text-align: center;
      margin-bottom: 30px;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }
    
    .form-group {
      margin-bottom: 25px;
    }
    
    .form-label {
      display: block;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.8);
      margin-bottom: 8px;
      letter-spacing: 1px;
    }
    
    .form-input {
      width: 100%;
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 4px;
      color: #ffffff;
      font-family: 'Inter', sans-serif;
      font-size: 16px;
      transition: all 0.3s ease;
    }
    
    .form-input:focus {
      outline: none;
      border-color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
      background: rgba(0, 0, 0, 0.8);
    }
    
    .form-input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }
    
    .modal-button {
      width: 100%;
      padding: 16px 24px;
      background: transparent;
      border: 2px solid #00ffff;
      color: #00ffff;
      font-family: 'JetBrains Mono', monospace;
      font-size: 18px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
      position: relative;
      overflow: hidden;
    }
    
    .modal-button:hover {
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
      transform: translateY(-2px);
    }
    
    .modal-button:active {
      transform: translateY(0);
    }
    
    .modal-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }
    
    .modal-button:hover::before {
      left: 100%;
    }
    
    /* Loading Effects */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(20px);
      z-index: 2000;
      display: none;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    .loading-overlay.active {
      display: flex;
      opacity: 1;
    }
    
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    .loading-text {
      font-family: 'JetBrains Mono', monospace;
      font-size: 24px;
      color: #00ffff;
      text-align: center;
      margin-bottom: 40px;
      text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
      animation: loading-pulse 2s ease-in-out infinite;
    }
    
    @keyframes loading-pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    
    .loading-progress {
      width: 300px;
      height: 4px;
      background: rgba(0, 255, 255, 0.2);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
      margin-bottom: 30px;
    }
    
    .loading-bar {
      height: 100%;
      background: linear-gradient(90deg, #00ffff, #ff00ff, #ffff00, #00ffff);
      background-size: 300% 100%;
      animation: loading-flow 3s ease-in-out infinite, loading-move 8s linear infinite;
      border-radius: 2px;
    }
    
    @keyframes loading-flow {
      0%, 100% { width: 0%; }
      50% { width: 100%; }
    }
    
    @keyframes loading-move {
      0% { background-position: 0% 50%; }
      100% { background-position: 300% 50%; }
    }
    
    .loading-status {
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(0, 255, 255, 0.8);
      text-align: center;
      margin-bottom: 20px;
      animation: status-flicker 1.5s ease-in-out infinite;
    }
    
    @keyframes status-flicker {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 0.4; }
    }
    
    .loading-scanline {
      position: absolute;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.8), transparent);
      animation: scanline-loading 4s linear infinite;
      pointer-events: none;
    }
    
    @keyframes scanline-loading {
      0% { transform: translateY(-50vh); }
      100% { transform: translateY(50vh); }
    }
    
    .loading-glitch {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
    }
    
    .loading-glitch::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, transparent 30%, rgba(0, 255, 255, 0.1) 50%, transparent 70%);
      animation: glitch-sweep 6s linear infinite;
    }
    
    @keyframes glitch-sweep {
      0% { transform: translateX(-100%) translateY(-100%); }
      100% { transform: translateX(100%) translateY(100%); }
    }
    
    .loading-matrix {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.1;
    }
    
    .matrix-rain {
      position: absolute;
      color: #00ffff;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      animation: matrix-fall 3s linear infinite;
    }
    
    @keyframes matrix-fall {
      0% { transform: translateY(-100px); opacity: 1; }
      100% { transform: translateY(100vh); opacity: 0; }
    }
    
    .loading-memory-fragments {
      position: absolute;
      color: rgba(0, 255, 255, 0.6);
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      pointer-events: none;
      animation: fragment-float 4s ease-in-out infinite;
    }
    
    @keyframes fragment-float {
      0%, 100% { opacity: 0.3; transform: translateY(0px); }
      50% { opacity: 0.8; transform: translateY(-10px); }
    }
    
    .modal-close {
      position: absolute;
      top: 15px;
      right: 20px;
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.6);
      font-size: 24px;
      cursor: pointer;
      transition: color 0.3s ease;
    }
    
    .modal-close:hover {
      color: #00ffff;
    }
    
    .error-message {
      color: #ff6b6b;
      font-size: 14px;
      margin-top: 5px;
      font-family: 'JetBrains Mono', monospace;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .error-message.show {
      opacity: 1;
    }
    
    .ticker {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 40px;
      background: rgba(0, 0, 0, 0.8);
      border-top: 1px solid rgba(0, 255, 255, 0.3);
      overflow: hidden;
      z-index: 50;
    }
    
    .ticker-content {
      display: flex;
      white-space: nowrap;
      animation: ticker-scroll 60s linear infinite;
    }
    
    @keyframes ticker-scroll {
      0% { transform: translateX(0%); }
      100% { transform: translateX(-50%); }
    }
    
    .ticker-item {
      display: inline-block;
      color: #00ffff;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      margin-right: 60px;
      opacity: 0.7;
      text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
    }
    
    .ticker-item.flicker {
      animation: flicker 2s infinite;
    }
    
    .ticker-item.glitch {
      animation: glitch 0.5s infinite;
    }
    
    .social-proof {
      position: absolute;
      color: rgba(0, 255, 255, 0.8);
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      opacity: 0;
      pointer-events: none;
      z-index: 20;
      text-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
      transition: opacity 1.5s ease-in-out;
    }
    
    .social-proof.visible {
      opacity: 1;
    }
    
    .social-proof.float-1 {
      animation: float1 8s ease-in-out infinite;
    }
    
    .social-proof.float-2 {
      animation: float2 10s ease-in-out infinite;
    }
    
    .social-proof.float-3 {
      animation: float3 12s ease-in-out infinite;
    }
    
    @keyframes float1 {
      0%, 100% { transform: translateY(0px) translateX(0px); }
      50% { transform: translateY(-15px) translateX(10px); }
    }
    
    @keyframes float2 {
      0%, 100% { transform: translateY(0px) translateX(0px); }
      50% { transform: translateY(10px) translateX(-8px); }
    }
    
    @keyframes float3 {
      0%, 100% { transform: translateY(0px) translateX(0px); }
      50% { transform: translateY(-8px) translateX(-12px); }
    }
    
    /* Audio Controls */
    .audio-controls {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    .audio-button {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(0, 255, 255, 0.3);
      color: #00ffff;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }
    
    .audio-button:hover {
      background: rgba(0, 255, 255, 0.1);
      border-color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    }
    
    .audio-button.muted {
      color: rgba(0, 255, 255, 0.5);
      border-color: rgba(0, 255, 255, 0.2);
    }
    
    .volume-slider {
      width: 80px;
      height: 4px;
      background: rgba(0, 255, 255, 0.2);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .volume-slider::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      background: #00ffff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }
    
    .volume-slider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #00ffff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }
    
    .audio-visualizer {
      position: fixed;
      bottom: 60px;
      left: 20px;
      z-index: 50;
      display: flex;
      align-items: end;
      gap: 2px;
      height: 60px;
    }
    
    .debug-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(0, 255, 255, 0.3);
      padding: 10px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: #00ffff;
      z-index: 1000;
      max-width: 200px;
      display: none;
    }
    
    .debug-panel.show {
      display: block;
    }
    
    .visualizer-bar {
      width: 3px;
      background: linear-gradient(to top, #00ffff, rgba(0, 255, 255, 0.3));
      border-radius: 2px;
      animation: visualizer-pulse 2s ease-in-out infinite;
    }
    
    @keyframes visualizer-pulse {
      0%, 100% { height: 10px; opacity: 0.3; }
      50% { height: 40px; opacity: 0.8; }
    }

    /* Reveal Overlay (Ken Burns + Captions) */
    .reveal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1600; /* Above radio-static */
      display: none;
      overflow: hidden;
    }
    .reveal-overlay.active { display: block; }
    .reveal-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center;
      transform-origin: center;
      will-change: transform;
      /* Animation set dynamically via JS for duration */
      animation-name: kenburns-pan;
      animation-timing-function: ease-in-out;
      animation-fill-mode: forwards;
    }
    @keyframes kenburns-pan {
      0% { transform: scale(1.05) translate3d(0, 0, 0); }
      100% { transform: scale(1.15) translate3d(2%, 2%, 0); }
    }
    .reveal-overlay::after {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(2px);
    }
    .reveal-caption {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(90vw, 900px);
      text-align: center;
      color: #e6ffff;
      font-family: 'Playfair Display', serif;
      line-height: 1.8;
      letter-spacing: 0.02em;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.25);
      z-index: 1;
      padding: 0 10px;
    }
    .reveal-line {
      opacity: 0;
      filter: blur(4px);
      transition: opacity 700ms ease, filter 1200ms ease;
      font-size: clamp(18px, 3.2vw, 34px);
    }
    .reveal-line.show {
      opacity: 1;
      filter: blur(0px);
    }

    /* Hide normal paragraph while reveal is active */
    .hidden-during-reveal { visibility: hidden; }
  </style>
</head>
<body class="liminal-bg min-h-screen">
  <!-- Audio Controls -->
  <div class="audio-controls">
    <button class="audio-button" id="audio-toggle">♪ LOADING...</button>
    <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="50">
  </div>
  
  <!-- Audio Visualizer -->
  <div class="audio-visualizer" id="audio-visualizer">
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
    <div class="visualizer-bar"></div>
  </div>
  
  <!-- Debug Panel -->
  <div class="debug-panel" id="debug-panel">
    <div>🔧 DEBUG MODE</div>
    <div id="speech-status">ElevenLabs: Loading...</div>
    <div id="voice-count">Voice: Matthew (Radio)</div>
    <button onclick="toggleDebug()" style="margin-top: 5px; padding: 2px 5px; font-size: 8px;">Toggle Debug</button>
  </div>

  <!-- Brand Section -->
  <div class="brand-section" id="brand-section">
    <div class="brand-container">
      <div class="brand-logo">VALLEXO</div>
      <div class="brand-tagline">You were there. You just forgot.</div>
    </div>
  </div>

  <!-- Scanline Effect -->
  <div class="scanline"></div>

  <!-- Reveal Overlay (Ken Burns + Captions) -->
  <div id="reveal-overlay" class="reveal-overlay">
    <div id="reveal-bg" class="reveal-bg" style="background-image: url('img/hallway1.png');"></div>
    <div id="reveal-caption" class="reveal-caption"></div>
  </div>
  
  <!-- Hero Section -->
  <section class="min-h-screen flex items-center justify-center px-4 relative" style="padding-top: 50px;">
    <div class="text-center max-w-5xl mx-auto relative z-10">
      <!-- Main Headline -->
      <h1 class="font-playfair text-4xl md:text-6xl lg:text-8xl font-bold text-gray-100 mb-8 leading-tight flicker-text">
        You were there.
      </h1>
      <h2 class="font-mono text-2xl md:text-4xl lg:text-6xl font-light text-cyan-300 mb-4 glitch-text">
        You just don't remember it yet.
      </h2>
      
      <!-- Subtext -->
      <p class="font-inter text-lg md:text-xl lg:text-2xl text-gray-300 mb-12 max-w-3xl mx-auto leading-relaxed neon-pulse">
        Pay $1 to remember something you never lived.
      </p>
      
      <!-- CTA Button -->
      <button 
        onclick="openModal()"
        class="glitch-button font-mono bg-transparent border-2 border-cyan-400 text-cyan-400 px-12 py-6 text-xl md:text-2xl font-medium hover:bg-cyan-400 hover:text-gray-900 transition-all duration-500"
      >
        Generate My Memory — $1
      </button>
      
      <!-- Ambient Text -->
      <div class="absolute top-1/4 left-1/4 text-xs text-gray-500 font-mono opacity-30 neon-pulse">
        MEMORY_001.CORRUPTED
      </div>
      <div class="absolute bottom-1/4 right-1/4 text-xs text-gray-500 font-mono opacity-30 neon-pulse">
        ACCESS_DENIED
      </div>
      <div class="absolute top-1/2 right-1/3 text-xs text-pink-400 font-mono opacity-40 flicker-text">
        SYSTEM_GLITCH
      </div>
    </div>
    
    <!-- Social Proof Container -->
    <div id="social-proof-container"></div>
  </section>

  <!-- Dream Journal Memory Section (hidden by default) -->
  <section id="memory-section" class="w-full flex justify-center opacity-0 pointer-events-none transition-opacity duration-1000" style="min-height: 300px;">
    <div class="max-w-2xl w-full bg-black bg-opacity-90 rounded-3xl shadow-2xl p-10 mt-10 mb-10 flex flex-col items-center border border-white/20" style="font-family: 'Playfair Display', serif;">
      <h2 class="text-3xl md:text-4xl font-bold mb-8 text-white text-center tracking-wide" style="letter-spacing:0.04em;">Here's what we remembered:</h2>
      <div class="flex flex-col md:flex-row items-center w-full gap-4">
        <p id="memory-text" class="text-xl md:text-2xl text-white text-center leading-relaxed md:leading-loose whitespace-pre-line flex-1" style="line-height:2.1; letter-spacing:0.01em;"></p>
        <div class="flex flex-col gap-2 mt-4 md:mt-0 md:ml-4">
          <button id="replay-narration" class="px-5 py-2 bg-cyan-500 bg-opacity-20 border border-cyan-400 hover:bg-opacity-40 text-cyan-300 rounded-lg transition-colors text-sm font-mono backdrop-filter: blur(2px);">
            📻 Replay Narration
          </button>
          <button id="copy-memory" class="px-5 py-2 bg-white bg-opacity-10 border border-white/30 hover:bg-opacity-30 text-white rounded-lg transition-colors text-sm font-serif" style="backdrop-filter: blur(2px);">Copy</button>
      </div>
      </div>
      
    </div>
  </section>
  <style>
    @keyframes fade-in-memory {
      from { opacity: 0; transform: translateY(40px); }
      to { opacity: 1; transform: translateY(0); }
    }
    #memory-section.fade-in {
      opacity: 1 !important;
      pointer-events: auto;
      animation: fade-in-memory 1.2s cubic-bezier(0.4,0,0.2,1);
    }
  </style>

  <!-- Memory Ticker -->
  <div class="ticker">
    <div class="ticker-content">
      <span class="ticker-item">RECALLING: MALL_1997.CORRUPTED</span>
      <span class="ticker-item flicker">ACCESSING: SCHOOL_HALLWAY_2001</span>
      <span class="ticker-item">LOADING: GRANDMA_HOUSE_1995</span>
      <span class="ticker-item glitch">ERROR: BEACH_VACATION_1999</span>
      <span class="ticker-item">PROCESSING: BIRTHDAY_PARTY_2003</span>
      <span class="ticker-item flicker">RECOVERING: CHRISTMAS_MORNING_1996</span>
      <span class="ticker-item">SCANNING: SUMMER_CAMP_2000</span>
      <span class="ticker-item glitch">CORRUPTED: FIRST_KISS_2005</span>
      <span class="ticker-item">DECODING: FAMILY_DINNER_1998</span>
      <span class="ticker-item flicker">RETRIEVING: ROAD_TRIP_2002</span>
      <span class="ticker-item">ANALYZING: SLEEPOVER_2004</span>
      <span class="ticker-item glitch">ERROR: PROM_NIGHT_2006</span>
      <span class="ticker-item">LOADING: BACKYARD_BBQ_1997</span>
      <span class="ticker-item flicker">PROCESSING: MOVIE_THEATER_2001</span>
      <span class="ticker-item">RECALLING: ICE_CREAM_SHOP_1999</span>
      <span class="ticker-item glitch">CORRUPTED: GRADUATION_2007</span>
      <span class="ticker-item">SCANNING: AMUSEMENT_PARK_2000</span>
      <span class="ticker-item flicker">ACCESSING: LIBRARY_STUDY_2003</span>
      <span class="ticker-item">DECODING: FISHING_TRIP_1996</span>
      <span class="ticker-item glitch">ERROR: FIRST_CAR_2005</span>
      <span class="ticker-item">RECALLING: MALL_1997.CORRUPTED</span>
      <span class="ticker-item flicker">ACCESSING: SCHOOL_HALLWAY_2001</span>
      <span class="ticker-item">LOADING: GRANDMA_HOUSE_1995</span>
      <span class="ticker-item glitch">ERROR: BEACH_VACATION_1999</span>
      <span class="ticker-item">PROCESSING: BIRTHDAY_PARTY_2003</span>
      <span class="ticker-item flicker">RECOVERING: CHRISTMAS_MORNING_1996</span>
      <span class="ticker-item">SCANNING: SUMMER_CAMP_2000</span>
      <span class="ticker-item glitch">CORRUPTED: FIRST_KISS_2005</span>
      <span class="ticker-item">DECODING: FAMILY_DINNER_1998</span>
      <span class="ticker-item flicker">RETRIEVING: ROAD_TRIP_2002</span>
      <span class="ticker-item">ANALYZING: SLEEPOVER_2004</span>
      <span class="ticker-item glitch">ERROR: PROM_NIGHT_2006</span>
      <span class="ticker-item">LOADING: BACKYARD_BBQ_1997</span>
      <span class="ticker-item flicker">PROCESSING: MOVIE_THEATER_2001</span>
      <span class="ticker-item">RECALLING: ICE_CREAM_SHOP_1999</span>
      <span class="ticker-item glitch">CORRUPTED: GRADUATION_2007</span>
      <span class="ticker-item">SCANNING: AMUSEMENT_PARK_2000</span>
      <span class="ticker-item flicker">ACCESSING: LIBRARY_STUDY_2003</span>
      <span class="ticker-item">DECODING: FISHING_TRIP_1996</span>
      <span class="ticker-item glitch">ERROR: FIRST_CAR_2005</span>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal-overlay" id="modal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal()">&times;</button>
      <h2 class="modal-title">Generate Your Memory</h2>
      
      <form id="memory-form">
        <div class="form-group">
          <label class="form-label">Your Full Name</label>
          <input type="text" class="form-input" id="fullname" placeholder="e.g. Evelyn Rose" required>
          <div class="error-message" id="name-error"></div>
        </div>
        
        <div class="form-group">
          <label class="form-label">Birth Year</label>
          <input type="number" class="form-input" id="birthYear" placeholder="e.g. 1996" min="1950" max="2010" required>
          <div class="error-message" id="birthYear-error"></div>
        </div>
        
        <button type="submit" class="modal-button">Generate My Memory →</button>
      </form>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading-overlay">
    <div class="loading-container">
      <div class="loading-scanline"></div>
      <div class="loading-glitch"></div>
      <div class="loading-matrix" id="loading-matrix"></div>
      
      <div class="loading-text" id="loading-text">RECONSTRUCTING MEMORY</div>
      <div class="loading-progress">
        <div class="loading-bar"></div>
      </div>
      <div class="loading-status" id="loading-status">ACCESSING NEURAL PATHWAYS...</div>
      
      <div class="loading-memory-fragments" id="memory-fragments"></div>
    </div>
  </div>

  <script>
    // Background Music System - Hybrid (Audio Files + Synthesized Fallback)
    let currentTrackIndex = 0;
    let audioElement = null;
    let audioFiles = [
      'audio/track1.mp3',
      'audio/track2.mp3',
      'audio/track3.mp3', 
      'audio/track4.mp3',
      'audio/track5.mp3'
    ];
    let isPlaying = false;
    let volume = 0.5;
    let usingAudioFiles = false;
    let audioContext = null;
    let synthesizedAudio = null;
    
    // Check if audio files exist
    async function checkAudioFiles() {
      let foundFiles = [];
      for (let i = 0; i < audioFiles.length; i++) {
        try {
          const response = await fetch(audioFiles[i], { method: 'HEAD' });
          if (response.ok) {
            console.log('Found audio file:', audioFiles[i]);
            foundFiles.push(audioFiles[i]);
          }
        } catch (error) {
          console.log('File not found:', audioFiles[i]);
        }
      }
      
      if (foundFiles.length > 0) {
        console.log('Found', foundFiles.length, 'audio files');
        audioFiles = foundFiles; // Use only the files that exist
        return true;
      } else {
        console.log('No audio files found, will use synthesized music');
        return false;
      }
    }
    
    // Initialize audio system
    async function initAudio() {
      try {
        // Check if we have audio files
        usingAudioFiles = await checkAudioFiles();
        
        if (usingAudioFiles) {
          // Use audio files
          return await initAudioFiles();
        } else {
          // Fall back to synthesized music
          return await initSynthesizedAudio();
        }
      } catch (error) {
        console.log('Audio initialization failed:', error);
        return false;
      }
    }
    
    // Initialize audio file playlist
    async function initAudioFiles() {
      try {
        audioElement = new Audio();
        audioElement.volume = volume;
        audioElement.preload = 'auto';
        
        audioElement.addEventListener('ended', playNextTrack);
        audioElement.addEventListener('error', handleAudioError);
        audioElement.addEventListener('canplaythrough', () => {
          console.log('Audio track loaded successfully');
        });
        
        loadTrack(currentTrackIndex);
        console.log('Audio file playlist system initialized');
        return true;
      } catch (error) {
        console.log('Audio file initialization failed:', error);
        return false;
      }
    }
    
    // Initialize synthesized audio fallback
    async function initSynthesizedAudio() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        masterGain.gain.value = volume;
        
        // Simple synthesized ambient track
        const drone = audioContext.createOscillator();
        const droneGain = audioContext.createGain();
        const droneFilter = audioContext.createBiquadFilter();
        
        drone.frequency.value = 220;
        drone.type = 'sine';
        droneGain.gain.value = 0.08;
        droneFilter.type = 'lowpass';
        droneFilter.frequency.value = 800;
        
        drone.connect(droneFilter);
        droneFilter.connect(droneGain);
        droneGain.connect(masterGain);
        
        synthesizedAudio = { 
          drone, 
          droneGain, 
          droneFilter, 
          masterGain,
          started: false  // Track if oscillator has been started
        };
        
        console.log('Synthesized audio fallback initialized');
        return true;
      } catch (error) {
        console.log('Synthesized audio initialization failed:', error);
        return false;
      }
    }
    
    // Load a specific track
    function loadTrack(index) {
      if (usingAudioFiles && audioFiles[index]) {
        audioElement.src = audioFiles[index];
        console.log('Loading track:', audioFiles[index]);
        
        // Add error handling for this specific track
        audioElement.onerror = (e) => {
          console.log('Failed to load track:', audioFiles[index], e);
          // Try next track after a short delay
          setTimeout(() => {
            playNextTrack();
          }, 1000);
        };
        
        // Add success handling
        audioElement.oncanplaythrough = () => {
          console.log('Track loaded successfully:', audioFiles[index]);
        };
      }
    }
    
    // Play next track
    function playNextTrack() {
      if (usingAudioFiles && audioFiles.length > 0) {
        currentTrackIndex = (currentTrackIndex + 1) % audioFiles.length;
        console.log('Moving to track', currentTrackIndex + 1, 'of', audioFiles.length);
        loadTrack(currentTrackIndex);
        if (isPlaying && audioElement) {
          audioElement.play().catch(error => {
            console.log('Auto-play failed for next track:', error);
            // If auto-play fails, try the next track
            setTimeout(() => {
              playNextTrack();
            }, 2000);
          });
        }
      } else {
        console.log('No more tracks available, stopping playlist');
        stopPlayback();
      }
    }
    
    // Handle audio errors
    function handleAudioError(e) {
      console.log('Audio error for track:', audioFiles[currentTrackIndex], e);
      console.log('Error details:', e.target.error);
      
      // Log specific error information
      if (e.target.error) {
        console.log('Error code:', e.target.error.code);
        console.log('Error message:', e.target.error.message);
      }
      
      console.log('Trying next track...');
      // Don't immediately call playNextTrack, let the onerror handler do it
    }
    
    // Start playing
    async function startPlayback() {
      if (!audioElement && !audioContext) {
        await initAudio();
      }
      
      try {
        if (usingAudioFiles && audioElement) {
          await audioElement.play();
          isPlaying = true;
          console.log('Audio file playlist started');
        } else if (audioContext && synthesizedAudio) {
          await audioContext.resume();
          if (!synthesizedAudio.started) {
            synthesizedAudio.drone.start();
            synthesizedAudio.started = true;
            console.log('Synthesized audio oscillator started');
          }
          isPlaying = true;
          console.log('Synthesized audio resumed');
        }
        return true;
      } catch (error) {
        console.log('Play failed:', error);
        return false;
      }
    }
    
    // Stop playing
    function stopPlayback() {
      if (usingAudioFiles && audioElement) {
        audioElement.pause();
      } else if (audioContext) {
        audioContext.suspend();
      }
      isPlaying = false;
      console.log('Audio stopped');
    }
    
    // Update volume
    function setVolume(newVolume) {
      volume = newVolume;
      if (usingAudioFiles && audioElement) {
        audioElement.volume = volume;
      } else if (synthesizedAudio && synthesizedAudio.masterGain) {
        synthesizedAudio.masterGain.gain.value = volume;
      }
    }
    
    // Volume ducking system
    let originalVolume = 0.5;
    let isDucking = false;
    
    // Duck background music during voiceover
    function duckBackgroundMusic() {
      if (!isDucking) {
        originalVolume = volume;
        setVolume(0.1); // Reduce to 10%
        isDucking = true;
        console.log('Background music ducked to 10% for voiceover');
      }
    }
    
    // Restore background music volume after voiceover
    function restoreBackgroundMusic() {
      if (isDucking) {
        setVolume(originalVolume);
        isDucking = false;
        console.log('Background music volume restored to', originalVolume);
      }
    }
    
    // Audio controls with better state management
    document.getElementById('audio-toggle').addEventListener('click', async function() {
      try {
        if (!audioElement && !audioContext) {
          await initAudio();
          if (!audioElement && !audioContext) {
            console.log('Failed to initialize audio system');
            return;
          }
        }
        
        if (isPlaying) {
          // Pause/Stop
          stopPlayback();
          this.textContent = '♪ OFF';
          this.classList.add('muted');
          console.log('Background music paused');
        } else {
          // Resume or start
          const success = await startPlayback();
          if (success) {
            this.textContent = '♪ ON';
            this.classList.remove('muted');
            console.log('Background music playing');
          } else {
            console.log('Failed to start audio playback');
          }
        }
      } catch (error) {
        console.log('Audio toggle error:', error);
        this.textContent = '♪ ERROR';
      }
    });
    
    // Volume control
    document.getElementById('volume-slider').addEventListener('input', function() {
      setVolume(this.value / 100);
    });
    
    // Initialize audio on page load with better error handling and default to ON
    window.addEventListener('load', function() {
      // Set default state to ON
      isPlaying = true;
      document.getElementById('audio-toggle').textContent = '♪ ON';
      document.getElementById('audio-toggle').classList.remove('muted');
      
      // Small delay to ensure page is fully loaded
      setTimeout(async () => {
        try {
          if (!audioElement && !audioContext) {
            await initAudio();
            if ((usingAudioFiles && audioElement) || (!usingAudioFiles && audioContext)) {
              const success = await startPlayback();
              if (success) {
                console.log('Background music auto-started successfully');
              } else {
                console.log('Background music needs user interaction to start');
              }
            } else {
              console.log('Background music needs user interaction to start');
            }
          }
        } catch (error) {
          console.log('Auto-start failed, will start on user interaction:', error);
        }
      }, 500);
    });
    
    // Initialize audio on first user interaction (fallback) - AGGRESSIVE AUTO-START
    document.addEventListener('click', async function initOnFirstClick() {
      try {
        if (!audioElement && !audioContext) {
          await initAudio();
        }
        
        // Always try to start/resume audio on first click if not already playing
        if (usingAudioFiles && audioElement && audioElement.paused) {
          await audioElement.play();
          if (!audioElement.paused) {
            isPlaying = true;
            document.getElementById('audio-toggle').textContent = '♪ ON';
            document.getElementById('audio-toggle').classList.remove('muted');
            console.log('Background music started on first user interaction');
          }
        } else if (!usingAudioFiles && audioContext && audioContext.state === 'suspended') {
          await audioContext.resume();
          if (synthesizedAudio && !synthesizedAudio.started) {
            synthesizedAudio.drone.start();
            synthesizedAudio.started = true;
          }
          if (audioContext.state === 'running') {
            isPlaying = true;
            document.getElementById('audio-toggle').textContent = '♪ ON';
            document.getElementById('audio-toggle').classList.remove('muted');
            console.log('Synthesized audio started on first user interaction');
          }
        }
        
        // Test speech synthesis on first click
        if ('speechSynthesis' in window) {
          const testUtterance = new SpeechSynthesisUtterance('Radio test');
          testUtterance.volume = 0;
          speechSynthesis.speak(testUtterance);
          console.log('Speech synthesis test completed');
        }
      } catch (error) {
        console.log('First click audio initialization failed:', error);
      }
      
      document.removeEventListener('click', initOnFirstClick);
    }, { once: true });
    
    // Simple visualizer for playlist (optional)
    function updateVisualizer() {
      const bars = document.querySelectorAll('.visualizer-bar');
      bars.forEach((bar, index) => {
        const delay = index * 0.1;
        const height = isPlaying ? 10 + Math.sin(Date.now() * 0.001 + delay) * 30 : 5;
        bar.style.height = height + 'px';
        bar.style.opacity = isPlaying ? 0.3 + Math.sin(Date.now() * 0.002 + delay) * 0.5 : 0.2;
      });
    }
    
    // Update visualizer continuously
    setInterval(updateVisualizer, 50);
    
    // Fake user actions for social proof
    const fakeUserActions = [
      "That night drive through a foggy highway in 2004 just came back.",
      "Recalled the quiet hum of fluorescent lights in a middle school hallway.",
      "A dusty couch, static-filled TV, and late-night Cartoon Network in 2007—unlocked.",
      "Memory of a birthday party at Chuck E. Cheese in 2001 just resurfaced.",
      "The empty mall food court in 2010 suddenly felt real again.",
      "He felt the classroom clock ticking during a 2003 math test.",
      "Just remembered hugging mom after the first day of 5th grade.",
      "The hum of a computer lab and that default Windows XP wallpaper... unlocked.",
      "Smell of McDonald's fries after a soccer game in 2006—back again.",
      "Her 2012 playlist just started playing in her head out of nowhere.",
      "A cold morning walk to the bus stop in Illinois just returned.",
      "They just saw the 2011 Orlando Christmas lights in their head.",
      "A hoodie, fall leaves, and Red Ribbon cake from Thanksgiving 2002—resurfaced.",
      "Remembered walking past Forever 21 in a half-empty mall—Quebec, 2013.",
      "The hallway outside the gym in Shibuya High, 2005. Vividly recalled.",
      "Someone remembered their Gangnam subway ride listening to 2NE1 in 2010.",
      "Texas summer heat, flip phones, and grape soda—memory reloaded.",
      "That birthday trip to Disneyland in 2009 is back.",
      "Saw a glimpse of prom night in a limo, Los Angeles 2011.",
      "The Taco Bell drive-thru line at 11 PM, Chicago, 2014.",
      "Just relived staring at glow-in-the-dark stars on their bedroom ceiling.",
      "Remembered their crush giving them a candy cane during 7th grade homeroom.",
      "Unlocked that exact moment of panic before a surprise pop quiz.",
      "The ice cream truck jingle echoing through the suburbs—it's back.",
      "That one awkward slow dance in the gym, Homecoming 2008.",
      "She remembered dad lifting her up to see fireworks in 2003.",
      "He just relived building LEGO on grandma's carpet in 2005.",
      "Recalling a rainy day spent in the school library, 2012.",
      "The purple Game Boy Advance and Mario Kart just reappeared in someone's head.",
      "The weird silence of a Target at 9 PM on Christmas Eve... returned.",
      "That one sunny afternoon in the park with grandpa, 2006.",
      "A late-night drive-thru at Sonic in 2013... somehow felt too real.",
      "Remembered laying on the grass watching clouds before phones ruled the world.",
      "Just saw an old AIM chat window in their head from 2010.",
      "Tangled Christmas lights and mom's voice—2004 came rushing back.",
      "The faint buzz of the TV left on all night, 2002.",
      "Back to scribbling in a diary with a gel pen, 2009.",
      "A classroom projector flickering during a movie day, 2007—just unlocked.",
      "A pizza party after the spelling bee in 2011—vividly remembered.",
      "Relived the smell of a Blockbuster carpet and stale popcorn.",
      "She remembered the scent of Abercrombie & Fitch while window shopping.",
      "An awkward middle school hallway bump with a crush—2008, perfectly recalled.",
      "The metallic taste of braces and cafeteria tater tots just returned.",
      "He heard the sound of a dial-up modem... again.",
      "Just saw the green laser lights of a roller rink from 2006.",
      "The first iPod Shuffle and that Avril Lavigne track—back from 2010.",
      "Tasting blue raspberry Icee from 7-Eleven in 2013 again.",
      "Remembered dad fixing a broken lamp in total silence.",
      "The 2015 Vine video binge spiral—randomly recalled.",
      "Recalled the exact moment the dog barked during their first kiss."
    ];

    // Social proof system
    let currentMessage = null;
    let usedMessages = [];
    let messageIndex = 0;

    function showSocialProof() {
      // Get next message with better cycling logic
      if (usedMessages.length >= fakeUserActions.length) {
        usedMessages = [];
        messageIndex = 0;
      }

      // If we're starting fresh, randomize the starting point
      if (usedMessages.length === 0) {
        messageIndex = Math.floor(Math.random() * fakeUserActions.length);
      }

      const message = fakeUserActions[messageIndex];
      usedMessages.push(message);
      messageIndex++;

      // Create new message element
      const messageEl = document.createElement('div');
      messageEl.className = 'social-proof';
      messageEl.textContent = message;

      // Random position
      const positions = [
        { top: '20%', left: '10%' },
        { top: '15%', right: '15%' },
        { bottom: '30%', left: '8%' },
        { bottom: '25%', right: '12%' },
        { top: '40%', left: '5%' },
        { top: '35%', right: '8%' },
        { bottom: '40%', left: '15%' },
        { bottom: '35%', right: '5%' }
      ];

      const position = positions[Math.floor(Math.random() * positions.length)];
      Object.assign(messageEl.style, position);

      // Random float animation
      const floatClasses = ['float-1', 'float-2', 'float-3'];
      messageEl.classList.add(floatClasses[Math.floor(Math.random() * floatClasses.length)]);

      // Add to container
      const container = document.getElementById('social-proof-container');
      container.appendChild(messageEl);

      // Show message
      setTimeout(() => {
        messageEl.classList.add('visible');
      }, 100);

      // Hide message after 4 seconds
      setTimeout(() => {
        messageEl.classList.remove('visible');
        setTimeout(() => {
          if (messageEl.parentNode) {
            messageEl.parentNode.removeChild(messageEl);
          }
        }, 1500);
      }, 4000);

      // Schedule next message
      setTimeout(() => {
        showSocialProof();
      }, 5500); // 4 seconds display + 1.5 seconds fade out
    }

    // Start social proof system with proper randomization
    setTimeout(() => {
      // Shuffle the array for better variety
      for (let i = fakeUserActions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [fakeUserActions[i], fakeUserActions[j]] = [fakeUserActions[j], fakeUserActions[i]];
      }
      showSocialProof();
    }, 2000);

    // Brand section scroll effect
    window.addEventListener('scroll', () => {
      const brandSection = document.getElementById('brand-section');
      if (window.scrollY > 50) {
        brandSection.classList.add('scrolled');
      } else {
        brandSection.classList.remove('scrolled');
      }
    });

    // Modal functionality
    function openModal() {
      const modal = document.getElementById('modal');
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
      
      // Focus on first input
      setTimeout(() => {
        document.getElementById('fullname').focus();
      }, 100);
    }

    function closeModal() {
      const modal = document.getElementById('modal');
      modal.classList.remove('active');
      document.body.style.overflow = 'auto';
      
      // Clear form
      document.getElementById('memory-form').reset();
      clearErrors();
    }

    function clearErrors() {
      document.getElementById('name-error').classList.remove('show');
      document.getElementById('birthYear-error').classList.remove('show');
    }

    // Close modal on ESC key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeModal();
      }
    });

    // Close modal on outside click
    document.getElementById('modal').addEventListener('click', (e) => {
      if (e.target.id === 'modal') {
        closeModal();
      }
    });

    // Remove OpenAI logic and use Supabase Edge Function
    async function generateMemory(name, birthYear) {
      // For production (replace with your actual Supabase project URL from dashboard)
      const urls = [
        'https://yhnsuovqpewwyqofrtaz.supabase.co/functions/v1/generateBio'
      ];
      
      // For local development (requires: supabase start)
      // const urls = [
      //   'http://127.0.0.1:54321/functions/v1/generateBio',
      //   '/functions/v1/generateBio'
      // ];
      
      for (const url of urls) {
        try {
          const requestBody = { name, birthYear };
          console.log('Sending to Supabase function:', requestBody);
          
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
          });
          if (!response.ok) {
            console.warn(`Failed with ${url}: ${response.status}`);
            continue;
          }
          const data = await response.json();
          console.log('Response from Supabase function:', data);
          if (data.memory) {
            return data.memory;
          } else {
            throw new Error('No memory returned');
          }
        } catch (error) {
          console.warn(`Error with ${url}:`, error);
          continue;
        }
      }
      throw new Error('Failed to generate memory. Please try again later.');
    }

    // Show memory section with fade-in and scroll - AFTER voiceover is ready
    async function showMemorySection(memoryText) {
      console.log('Preparing memory section and voiceover...');
      
      const section = document.getElementById('memory-section');
      const textEl = document.getElementById('memory-text');
      textEl.textContent = memoryText;
      
      // Start voiceover preparation while showing the section
      try {
        await narrateMemory(memoryText); // Wait for voiceover to be ready
        console.log('Voiceover ready, showing memory section');
      } catch (error) {
        console.log('Voiceover failed, showing section anyway:', error);
      }
      
      // Show the section
      section.classList.add('fade-in');
      section.classList.remove('opacity-0', 'pointer-events-none');
      setTimeout(() => {
        section.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }, 300);
    }
    
    // Debug functions
    function toggleDebug() {
      const debugPanel = document.getElementById('debug-panel');
      debugPanel.classList.toggle('show');
      updateDebugInfo();
    }
    
    function updateDebugInfo() {
      const speechStatus = document.getElementById('speech-status');
      const voiceCount = document.getElementById('voice-count');
      
      // Update to show OpenAI TTS status
      speechStatus.textContent = 'OpenAI TTS: Active';
      voiceCount.textContent = 'Voice: Onyx (1950s Radio)';
      console.log('Using OpenAI TTS with Onyx voice for 1950s radio host narration');
    }
    
    // Add natural pauses and emphasis to text - OPTIMIZED FOR CREDITS
    function addNaturalPauses(text) {
      // Limit text length to save credits  
      const maxLength = 2500; // Increased for longer memories
      if (text.length > maxLength) {
        text = text.substring(0, maxLength) + '...';
        console.log('Text truncated to save credits:', text.length, 'characters');
      }
      
      // DON'T add instruction to the text - let OpenAI TTS handle the voice style
      let enhanced = text;
      
      // Clean up text formatting
      enhanced = enhanced
        .replace(/\./g, '. ')
        .replace(/,/g, ', ')
        .replace(/([.!?])\s+/g, '$1 ');
      
      // Only emphasize key words (reduced list)
      const keyWords = [
        'remember', 'memory', 'felt', 'saw', 'heard',
        'moment', 'time', 'place', 'feeling'
      ];
      
      keyWords.forEach(word => {
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        enhanced = enhanced.replace(regex, `<emphasis level="moderate">${word}</emphasis>`);
      });
      
      // Add natural pauses between sentences
      enhanced = enhanced.replace(/([.!?])\s+/g, '$1<break time="50ms"/> ');
      
      return enhanced;
    }
    
    // OpenAI TTS realistic radio announcer narration
    async function narrateMemory(memoryText) {
      console.log('Attempting to narrate memory with OpenAI TTS:', memoryText.substring(0, 50) + '...');
      
      try {
        // Add radio static effect immediately
        addRadioStaticEffect();
        
        // Duck background music for voiceover
        duckBackgroundMusic();
        
        // Enhanced text for better narration
        const enhancedText = addNaturalPauses(memoryText);
        
        // Sanitize text for JSON transmission
        const sanitizedText = enhancedText
          .replace(/\n/g, ' ')  // Replace newlines with spaces
          .replace(/\r/g, ' ')  // Replace carriage returns with spaces
          .replace(/\t/g, ' ')  // Replace tabs with spaces
          .replace(/\s+/g, ' ') // Replace multiple spaces with single space
          .trim();               // Remove leading/trailing spaces
        
        console.log('Sanitized text length:', sanitizedText.length);
        
        // Call OpenAI TTS API via Supabase Edge Function
        console.log('🎙️ CALLING GENERATE SPEECH V2 WITH NEW API KEY');
        console.log('📞 Endpoint: generateSpeechV2 (NOT generateSpeech)');
        console.log('🔑 Expected: New API key should work');
        console.log('Request URL:', 'https://yhnsuovqpewwyqofrtaz.supabase.co/functions/v1/generateSpeechV2?v=4&t=' + Date.now());
        console.log('Request body:', JSON.stringify({ text: sanitizedText }));
        
        const response = await fetch('https://yhnsuovqpewwyqofrtaz.supabase.co/functions/v1/generateSpeechV2?v=4&t=' + Date.now(), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlobnN1b3ZxcGV3d3lxb2ZydGF6Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MzYzMzc3MywiZXhwIjoyMDY5MjA5NzczfQ.pABYaslGn8LPxR0vlt3q2F4Y27hFxpmV74yG0Q53JHk'
          },
          body: JSON.stringify({
            text: sanitizedText
          })
        });
        
        console.log('OpenAI TTS response status:', response.status);
        
        if (!response.ok) {
          const errorData = await response.json();
          console.error('OpenAI TTS error:', errorData);
          throw new Error(`OpenAI TTS error: ${response.status} - ${JSON.stringify(errorData)}`);
        }
        
        const data = await response.json();
        console.log('OpenAI TTS success:', data);
        
        if (data.audio) {
          // Convert base64 to audio blob
          const audioData = atob(data.audio);
          const audioArray = new Uint8Array(audioData.length);
          for (let i = 0; i < audioData.length; i++) {
            audioArray[i] = audioData.charCodeAt(i);
          }
          
          const audioBlob = new Blob([audioArray], { type: 'audio/mp3' });
          const audioUrl = URL.createObjectURL(audioBlob);
          
          // Create and play audio
          const audio = new Audio(audioUrl);
          audio.volume = 0.9;

          // Prepare reveal when metadata is ready
          let boundaryTimes = null;
          let boundaryPromise = null;
          audio.addEventListener('loadedmetadata', () => {
            const bg = document.getElementById('reveal-bg');
            const dur = Math.max(6, Math.min(240, Math.floor(audio.duration || 20)));
            if (bg) bg.style.animationDuration = dur + 's';
            if (Number.isFinite(audio.duration) && audio.duration > 0) {
              const sentenceCount = splitMemoryIntoLines(memoryText).length;
              if (Array.isArray(data.segments) && data.segments.length) {
                console.log('Using Whisper segments for caption timing (text-aligned)');
                boundaryPromise = Promise.resolve(boundariesFromSegmentsAndText(data.segments, memoryText, audio.duration))
                  .then(bt => (Array.isArray(bt) && bt.length ? bt : boundariesFromWhisperSegments(data.segments, sentenceCount, audio.duration)));
              } else {
                console.log('No Whisper segments; using offline silence analysis with calibrated reading-time snapping');
                boundaryPromise = extractSilenceBoundariesFromBlob(audioBlob)
                  .then(rawSilences => {
                    const est = computeBoundaryTimesForLines(memoryText, audio.duration);
                    return snapBoundariesToSilences(est, rawSilences, audio.duration);
                  })
                  .catch(() => computeBoundaryTimesForLines(memoryText, audio.duration));
              }
            }
          });
          
          audio.onplay = async () => {
            console.log('OpenAI TTS narration started');
            updateDebugInfo();
            // Force fixed 2.5s per line captions
            revealSync.fixedSecondsPerLine = 2.5;
            // Start synchronized reveal
            try {
              const btResolved = await (boundaryPromise || Promise.resolve(boundaryTimes));
              const bt = Array.isArray(btResolved) && btResolved.length ? btResolved : computeBoundaryTimesForLines(memoryText, Math.max(6, audio.duration || 20));
              startKenBurnsReveal(memoryText, audio, null, bt);
            } catch (_) {
              const bt = computeBoundaryTimesForLines(memoryText, Math.max(6, audio.duration || 20));
              startKenBurnsReveal(memoryText, audio, null, bt);
            }
          };
          
          audio.onended = () => {
            console.log('OpenAI TTS narration ended');
            removeRadioStaticEffect();
            restoreBackgroundMusic(); // Restore background music volume
            URL.revokeObjectURL(audioUrl); // Clean up
            stopKenBurnsReveal();
          };
          
          audio.onerror = (error) => {
            console.error('OpenAI TTS audio error:', error);
            removeRadioStaticEffect();
            restoreBackgroundMusic(); // Restore background music volume
            URL.revokeObjectURL(audioUrl);
            alert('Audio playback failed. Please try clicking the "Replay Narration" button.');
            stopKenBurnsReveal();
          };
          
          // Start playing
          await audio.play();
          
        } else {
          throw new Error('No audio data received from OpenAI TTS');
        }
        
      } catch (error) {
        console.error('Error in OpenAI TTS narration:', error);
        removeRadioStaticEffect();
        restoreBackgroundMusic(); // Restore background music volume
        
        // Fallback to Web Speech API if OpenAI TTS fails
        console.log('Falling back to Web Speech API...');
        fallbackToWebSpeech(memoryText);
      }
    }
    
    // Fallback to Web Speech API
    function fallbackToWebSpeech(memoryText) {
      if ('speechSynthesis' in window) {
        speechSynthesis.cancel();
        
        // Duck background music for voiceover
        duckBackgroundMusic();
        
        const utterance = new SpeechSynthesisUtterance(memoryText);
        utterance.rate = 0.85;
        utterance.pitch = 0.9;
        utterance.volume = 0.95;
        
        utterance.onstart = () => {
          console.log('Fallback Web Speech narration started');
          updateDebugInfo();
          // Force fixed 2.5s per line captions
          revealSync.fixedSecondsPerLine = 2.5;
          startKenBurnsReveal(memoryText, null, utterance);
        };
        
        utterance.onend = () => {
          console.log('Fallback Web Speech narration ended');
          removeRadioStaticEffect();
          restoreBackgroundMusic(); // Restore background music volume
          stopKenBurnsReveal();
        };
        
        utterance.onerror = (event) => {
          console.log('Fallback Web Speech error:', event);
          removeRadioStaticEffect();
          restoreBackgroundMusic(); // Restore background music volume
          alert('Speech synthesis failed. Please try again.');
        };
        
        speechSynthesis.speak(utterance);
      } else {
        alert('Speech synthesis is not supported in this browser.');
      }
    }
    
    // Add radio static effect during narration
    function addRadioStaticEffect() {
      // Create static overlay
      const staticOverlay = document.createElement('div');
      staticOverlay.id = 'radio-static';
      staticOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 50% 50%, transparent 0%, rgba(0, 255, 255, 0.05) 50%, transparent 100%);
        pointer-events: none;
        z-index: 1500;
        animation: radio-static 0.1s linear infinite;
      `;
      
      // Add static animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes radio-static {
          0% { opacity: 0.1; transform: translateX(0px); }
          25% { opacity: 0.2; transform: translateX(1px); }
          50% { opacity: 0.1; transform: translateX(-1px); }
          75% { opacity: 0.15; transform: translateX(0.5px); }
          100% { opacity: 0.1; transform: translateX(0px); }
        }
      `;
      document.head.appendChild(style);
      document.body.appendChild(staticOverlay);
      
      // Add radio frequency display
      const radioDisplay = document.createElement('div');
      radioDisplay.id = 'radio-display';
      radioDisplay.style.cssText = `
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid rgba(0, 255, 255, 0.5);
        padding: 10px 15px;
        font-family: 'JetBrains Mono', monospace;
        color: #00ffff;
        font-size: 12px;
        z-index: 1501;
        backdrop-filter: blur(10px);
        animation: radio-display-glow 2s ease-in-out infinite;
      `;
      radioDisplay.innerHTML = `
        <div>📻 RADIO VALLEXO</div>
        <div style="font-size: 10px; opacity: 0.7;">FREQ: 88.5 MHz</div>
        <div style="font-size: 10px; opacity: 0.7;">SIGNAL: STRONG</div>
      `;
      document.body.appendChild(radioDisplay);
      
      // Add radio display glow animation
      const radioStyle = document.createElement('style');
      radioStyle.textContent = `
        @keyframes radio-display-glow {
          0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
          50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }
        }
      `;
      document.head.appendChild(radioStyle);
    }
    
    // Remove radio static effect
    function removeRadioStaticEffect() {
      const staticOverlay = document.getElementById('radio-static');
      const radioDisplay = document.getElementById('radio-display');
      
      if (staticOverlay) {
        staticOverlay.remove();
      }
      if (radioDisplay) {
        radioDisplay.remove();
      }
    }

    // Copy button logic
    document.getElementById('copy-memory').addEventListener('click', function() {
      const text = document.getElementById('memory-text').textContent;
      navigator.clipboard.writeText(text);
    });
    
    // Replay narration button logic
    document.getElementById('replay-narration').addEventListener('click', function() {
      const memoryText = document.getElementById('memory-text').textContent;
      if (memoryText) {
        // Replay the TTS narration
        narrateMemory(memoryText);
      }
    });
    
    // Initialize speech synthesis on page load
    window.addEventListener('load', function() {
      if ('speechSynthesis' in window) {
        // Trigger voice loading
        speechSynthesis.getVoices();
        console.log('Speech synthesis initialized');
        updateDebugInfo();
        
        // Wait for voices to load and log the best ones
        setTimeout(() => {
          const voices = speechSynthesis.getVoices();
          const naturalVoices = voices.filter(v => 
            v.name.toLowerCase().includes('natural') ||
            v.name.toLowerCase().includes('google') ||
            v.name.toLowerCase().includes('microsoft') ||
            v.name.toLowerCase().includes('premium')
          );
          console.log('Natural-sounding voices available:', naturalVoices.map(v => v.name));
        }, 2000);
      }
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      // Ctrl/Cmd + D to toggle debug
      if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault();
        toggleDebug();
      }
    });

    // Loading animation functions
    function showLoadingOverlay() {
      const overlay = document.getElementById('loading-overlay');
      overlay.classList.add('active');
      
      // Start matrix rain effect
      startMatrixRain();
      
      // Start memory fragments
      startMemoryFragments();
      
      // Update loading text and status
      updateLoadingText();
    }
    
    function hideLoadingOverlay() {
      const overlay = document.getElementById('loading-overlay');
      overlay.classList.remove('active');
      
      // Clear matrix rain
      const matrix = document.getElementById('loading-matrix');
      matrix.innerHTML = '';
      
      // Clear memory fragments
      const fragments = document.getElementById('memory-fragments');
      fragments.innerHTML = '';
    }
    
    function startMatrixRain() {
      const matrix = document.getElementById('loading-matrix');
      const characters = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
      
      setInterval(() => {
        const rain = document.createElement('div');
        rain.className = 'matrix-rain';
        rain.style.left = Math.random() * 100 + '%';
        rain.style.animationDelay = Math.random() * 2 + 's';
        rain.textContent = characters[Math.floor(Math.random() * characters.length)];
        matrix.appendChild(rain);
        
        // Remove after animation
        setTimeout(() => {
          if (rain.parentNode) {
            rain.parentNode.removeChild(rain);
          }
        }, 3000);
      }, 100);
    }
    
    function startMemoryFragments() {
      const fragments = document.getElementById('memory-fragments');
      const fragmentTexts = [
        'flickering screen...',
        'warm carpet fibers...',
        'distant laughter...',
        'static hum...',
        'glowing dials...',
        'whispered secrets...',
        'crackling vinyl...',
        'neon reflections...',
        'dust motes dancing...',
        'echoing footsteps...',
        'radio static...',
        'fading light...',
        'cold metal...',
        'warm breath...',
        'distant thunder...',
        'cigarette smoke...',
        'rain on windows...',
        'old photographs...',
        'telephone rings...',
        'car engine hum...'
      ];
      
      setInterval(() => {
        const fragment = document.createElement('div');
        fragment.className = 'loading-memory-fragments';
        fragment.style.left = Math.random() * 80 + 10 + '%';
        fragment.style.top = Math.random() * 80 + 10 + '%';
        fragment.style.animationDelay = Math.random() * 2 + 's';
        fragment.textContent = fragmentTexts[Math.floor(Math.random() * fragmentTexts.length)];
        fragments.appendChild(fragment);
        
        // Remove after animation
        setTimeout(() => {
          if (fragment.parentNode) {
            fragment.parentNode.removeChild(fragment);
          }
        }, 4000);
      }, 800);
    }
    
    function updateLoadingText() {
      const loadingText = document.getElementById('loading-text');
      const loadingStatus = document.getElementById('loading-status');
      
      const loadingPhases = [
        { text: 'RECONSTRUCTING MEMORY', status: 'ACCESSING NEURAL PATHWAYS...' },
        { text: 'SCANNING TIMELINE', status: 'LOCATING MEMORY FRAGMENTS...' },
        { text: 'DECODING SIGNALS', status: 'ANALYZING EMOTIONAL PATTERNS...' },
        { text: 'SYNCHRONIZING DATA', status: 'RECONSTRUCTING SCENES...' },
        { text: 'PREPARING VOICEOVER', status: 'GENERATING AUDIO NARRATION...' },
        { text: 'FINALIZING MEMORY', status: 'RENDERING EXPERIENCE...' }
      ];
      
      let phaseIndex = 0;
      const textInterval = setInterval(() => {
        if (phaseIndex < loadingPhases.length) {
          loadingText.textContent = loadingPhases[phaseIndex].text;
          loadingStatus.textContent = loadingPhases[phaseIndex].status;
          phaseIndex++;
        } else {
          clearInterval(textInterval);
        }
      }, 2000);
    }

    // Update form submit handler to show memory section
    document.getElementById('memory-form').addEventListener('submit', async function(e) {
      e.preventDefault();
      clearErrors();
      const fullname = document.getElementById('fullname').value.trim();
      const birthYear = parseInt(document.getElementById('birthYear').value, 10);
      let hasErrors = false;
      if (!fullname) {
        document.getElementById('name-error').textContent = 'Please enter your full name';
        document.getElementById('name-error').classList.add('show');
        hasErrors = true;
      }
      if (!birthYear) {
        document.getElementById('birthYear-error').textContent = 'Please enter your birth year';
        document.getElementById('birthYear-error').classList.add('show');
        hasErrors = true;
      } else if (birthYear < 1950 || birthYear > 2010) {
        document.getElementById('birthYear-error').textContent = 'Please enter a birth year between 1950-2010';
        document.getElementById('birthYear-error').classList.add('show');
        hasErrors = true;
      }
      if (!hasErrors) {
          closeModal();
        showLoadingOverlay();
        
        try {
          const memory = await generateMemory(fullname, birthYear);
          // Start voice + UI
          await showMemorySection(memory);
          hideLoadingOverlay();
        } catch (error) {
          hideLoadingOverlay();
          // Show error in a new modal or overlay
          alert('Failed to generate memory. Please try again.');
        }
      }
    });

    // Add random glitch effects
    setInterval(() => {
      const elements = document.querySelectorAll('.glitch-text, .flicker-text');
      const randomElement = elements[Math.floor(Math.random() * elements.length)];
      randomElement.style.animation = 'none';
      setTimeout(() => {
        randomElement.style.animation = '';
      }, 100);
    }, 3000);

    // Smooth scroll
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        document.querySelector(this.getAttribute('href')).scrollIntoView({
          behavior: 'smooth'
        });
      });
    });
    // -------- Ken Burns + Caption sequencing --------
    // Build sentence-level boundaries from Whisper segments (uniform snap)
    function boundariesFromWhisperSegments(segments, sentenceCount, totalDurationSec) {
      try {
        if (!Array.isArray(segments) || !segments.length || !sentenceCount || !Number.isFinite(totalDurationSec)) {
          return [];
        }
        // Construct cumulative boundaries from segments
        const segBounds = [0];
        for (let i = 0; i < segments.length; i++) {
          const end = typeof segments[i].end === 'number' ? segments[i].end : 0;
          if (Number.isFinite(end)) segBounds.push(Math.max(segBounds[segBounds.length - 1], end));
        }
        // Ensure final boundary equals total duration
        const last = segBounds[segBounds.length - 1];
        if (!Number.isFinite(last) || Math.abs(last - totalDurationSec) > 0.25) {
          segBounds[segBounds.length - 1] = totalDurationSec;
        }

        // If we already have the exact count, return
        if (segBounds.length === sentenceCount + 1) {
          return segBounds;
        }

        // Otherwise resample to sentenceCount+1 evenly across time, snapping to nearest segment boundary
        const out = [0];
        for (let i = 1; i < sentenceCount; i++) {
          const target = (i / sentenceCount) * totalDurationSec;
          let nearest = segBounds[0];
          let best = Math.abs(nearest - target);
          for (let j = 1; j < segBounds.length; j++) {
            const d = Math.abs(segBounds[j] - target);
            if (d < best) { best = d; nearest = segBounds[j]; }
          }
          out.push(Math.max(0, Math.min(totalDurationSec, nearest)));
        }
        out.push(totalDurationSec);
        for (let i = 1; i < out.length; i++) {
          if (out[i] < out[i - 1]) out[i] = out[i - 1];
        }
        return out;
      } catch (e) {
        console.warn('boundariesFromWhisperSegments failed:', e);
        return [];
      }
    }

    // Build sentence-level boundaries by aligning Whisper segments to the actual sentence text
    function boundariesFromSegmentsAndText(segments, fullText, totalDurationSec) {
      try {
        const sentences = splitMemoryIntoLines(fullText);
        if (!Array.isArray(segments) || !segments.length || !sentences.length) return [];

        const normalize = (s) => (s || '')
          .toLowerCase()
          // include all characters (we only collapse whitespace)
          .replace(/\s+/g, ' ')                  // collapse whitespace
          .trim();

        const normSentences = sentences.map(normalize);
        const segs = segments.map(s => ({
          start: typeof s.start === 'number' ? s.start : 0,
          end: typeof s.end === 'number' ? s.end : 0,
          text: normalize(s.text)
        }));

        const boundaries = [0];
        let sIdx = 0;
        let accum = '';
        let lastEnd = 0;

        const MIN_SENT_DUR = 1.6; // guardrail minimum per chunk
        const MAX_CLAMP = Math.max(6, totalDurationSec || 0);

        for (let i = 0; i < segs.length && sIdx < normSentences.length; i++) {
          const seg = segs[i];
          accum += (accum ? ' ' : '') + seg.text;
          lastEnd = Math.max(lastEnd, seg.end);
          // Heuristic: advance when accumulated length reaches or exceeds sentence length * 0.9
          const target = normSentences[sIdx];
          if (!target || !accum) continue;
          if (accum.length >= Math.max(1, Math.floor(target.length * 0.9))) {
            // Set boundary at segment end for this sentence
            const prev = boundaries[boundaries.length - 1];
            const proposed = Math.max(prev + MIN_SENT_DUR, Math.min(MAX_CLAMP, lastEnd));
            boundaries.push(proposed);
            sIdx++;
            accum = '';
          }
        }

        // If we didn't fill all, distribute remaining evenly until totalDurationSec
        if (sIdx < normSentences.length) {
          const remaining = normSentences.length - sIdx;
          const last = boundaries[boundaries.length - 1];
          const restDur = Math.max(0, (Number.isFinite(totalDurationSec) ? totalDurationSec : last) - last);
          const per = remaining > 0 ? Math.max(MIN_SENT_DUR, restDur / remaining) : 0;
          for (; sIdx < normSentences.length; sIdx++) {
            boundaries.push(Math.min(MAX_CLAMP, boundaries[boundaries.length - 1] + per));
          }
        }

        // Ensure total ends at totalDurationSec when known
        if (Number.isFinite(totalDurationSec) && totalDurationSec > 0) {
          boundaries[boundaries.length - 1] = totalDurationSec;
        }

        // Ensure monotonic non-decreasing and correct count (sentences + 1)
        for (let i = 1; i < boundaries.length; i++) {
          if (boundaries[i] < boundaries[i - 1]) boundaries[i] = boundaries[i - 1];
        }
        const desiredLen = sentences.length + 1;
        if (boundaries.length !== desiredLen) {
          // Resample to desired length by linear interpolation
          const out = [0];
          const last = boundaries[boundaries.length - 1];
          for (let i = 1; i < desiredLen - 1; i++) {
            const target = (i / (desiredLen - 1)) * last;
            // find nearest in boundaries
            let nearest = boundaries[0];
            let best = Math.abs(nearest - target);
            for (let j = 1; j < boundaries.length; j++) {
              const d = Math.abs(boundaries[j] - target);
              if (d < best) { best = d; nearest = boundaries[j]; }
            }
            out.push(nearest);
          }
          out.push(last);
          return out;
        }
        return boundaries;
      } catch (e) {
        console.warn('boundariesFromSegmentsAndText failed:', e);
        return [];
      }
    }

    // Snap estimated boundaries to nearest detected silences for reliability
    function snapBoundariesToSilences(estimatedBoundaries, rawSilences, totalDurationSec) {
      try {
        if (!Array.isArray(estimatedBoundaries) || estimatedBoundaries.length < 2) return estimatedBoundaries || [];
        if (!Array.isArray(rawSilences) || rawSilences.length < 2) return estimatedBoundaries;

        const out = [];
        for (let i = 0; i < estimatedBoundaries.length; i++) {
          const t = estimatedBoundaries[i];
          // Keep first and last untouched
          if (i === 0 || i === estimatedBoundaries.length - 1) {
            out.push(t);
            continue;
          }
          // Find nearest raw silence
          let nearest = rawSilences[0];
          let best = Math.abs(nearest - t);
          for (let j = 1; j < rawSilences.length; j++) {
            const d = Math.abs(rawSilences[j] - t);
            if (d < best) { best = d; nearest = rawSilences[j]; }
          }
          out.push(Math.max(0, Math.min(totalDurationSec, nearest)));
        }
        // Ensure monotonic non-decreasing
        for (let i = 1; i < out.length; i++) {
          if (out[i] < out[i - 1]) out[i] = out[i - 1];
        }
        return out;
      } catch (e) {
        console.warn('snapBoundariesToSilences failed:', e);
        return estimatedBoundaries;
      }
    }
    // Fixed-width segmentation: group into 3–4 words per line (include all text)
    function splitMemoryIntoLines(text) {
      if (!text) return [];
      const raw = text.replace(/\s+/g, ' ').trim();
      const words = raw.split(/\s+/).filter(Boolean);
      const lines = [];
      const TARGET = 4;
      const MIN = 3;

      for (let i = 0; i < words.length; i += TARGET) {
        let chunk = words.slice(i, i + TARGET);
        // If last chunk would be shorter than MIN, merge it with previous line
        if (chunk.length < MIN && lines.length) {
          const prev = lines.pop();
          chunk = (prev + ' ' + chunk.join(' ')).trim().split(/\s+/);
        }
        lines.push(chunk.join(' '));
      }
      return lines;
    }

    // Compute time boundaries per sentence using reading-time model tied to TTS speed
    function computeBoundaryTimesForLines(text, totalDurationSec) {
      const sentences = splitMemoryIntoLines(text);
      if (!sentences.length || !Number.isFinite(totalDurationSec) || totalDurationSec <= 0) return [];

      const TTS_SPEED = 1.0;         // must match generateSpeechV2
      const WORDS_PER_SECOND = 1.6 * TTS_SPEED; // ~96 wpm at 1.0 (slower to avoid outpacing)
      const MIN_PER_SENTENCE = 2.2;  // increase minimum display per sentence
      const BONUS_COMMA = 0.25;
      const BONUS_SEMI = 0.35;
      const BONUS_END = 0.5;

      // Raw durations per sentence
      const baseDurations = sentences.map((s) => {
        const t = s.trim();
        const words = t.split(/\s+/).filter(Boolean).length;
        const commas = (t.match(/,/g) || []).length;
        const semis = (t.match(/[;:]/g) || []).length;
        const endPunct = /[.!?]$/.test(t) ? BONUS_END : 0;
        const est = (words / Math.max(0.1, WORDS_PER_SECOND)) + commas * BONUS_COMMA + semis * BONUS_SEMI + endPunct;
        return Math.max(MIN_PER_SENTENCE, est);
      });

      // Fit to totalDurationSec while respecting per-sentence minimums
      const minTotal = sentences.length * MIN_PER_SENTENCE;
      let durations;
      if (totalDurationSec <= minTotal) {
        // Extremely short audio: distribute evenly at min
        const per = totalDurationSec / sentences.length;
        durations = new Array(sentences.length).fill(per);
      } else {
        const extras = baseDurations.map(d => d - MIN_PER_SENTENCE);
        const sumExtras = extras.reduce((a,b)=>a+b,0) || 1;
        const availExtras = totalDurationSec - minTotal;
        const scale = availExtras / sumExtras;
        durations = extras.map(e => MIN_PER_SENTENCE + e * scale);
      }

      // Build cumulative boundaries
      const times = [0];
      let acc = 0;
      for (let i = 0; i < durations.length - 1; i++) {
        acc += durations[i];
        times.push(Math.min(totalDurationSec, acc));
      }
      times.push(totalDurationSec);
      return times;
    }

    // Offline silence detector using Web Audio API (no external services)
    async function extractSilenceBoundariesFromBlob(audioBlob) {
      const arrayBuffer = await audioBlob.arrayBuffer();
      const ctx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100 * 60, 44100);
      const audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
      const channel = audioBuffer.getChannelData(0);
      const sampleRate = audioBuffer.sampleRate;

      // Parameters tuned for speech-like audio
      const frameSize = Math.floor(sampleRate * 0.04); // 40ms frames
      const hopSize = Math.floor(frameSize / 2);        // 20ms hop
      const silenceThreshold = 0.02;                    // amplitude threshold
      const minSilenceSec = 0.15;                       // min 150ms to count as boundary

      const rms = (start) => {
        let sum = 0;
        for (let i = start; i < Math.min(start + frameSize, channel.length); i++) {
          const v = channel[i];
          sum += v * v;
        }
        return Math.sqrt(sum / frameSize);
      };

      const candidates = [];
      let runStart = null;
      for (let i = 0; i < channel.length; i += hopSize) {
        const value = rms(i);
        const t = i / sampleRate;
        if (value < silenceThreshold) {
          if (runStart === null) runStart = t;
        } else {
          if (runStart !== null) {
            const dur = t - runStart;
            if (dur >= minSilenceSec) candidates.push({ start: runStart, end: t });
            runStart = null;
          }
        }
      }
      // If trailing silence
      if (runStart !== null) {
        const t = channel.length / sampleRate;
        const dur = t - runStart;
        if (dur >= minSilenceSec) candidates.push({ start: runStart, end: t });
      }

      // Use midpoints of silence regions as boundaries
      const boundaries = [0];
      for (const s of candidates) {
        const mid = (s.start + s.end) / 2;
        boundaries.push(mid);
      }
      boundaries.push(channel.length / sampleRate);
      // Ensure sorted unique
      boundaries.sort((a, b) => a - b);
      const uniq = [];
      for (let i = 0; i < boundaries.length; i++) {
        if (i === 0 || boundaries[i] - boundaries[i - 1] > 0.05) uniq.push(boundaries[i]);
      }
      return uniq;
    }

    // Adapt raw time boundaries to match the number of lines
    function adaptBoundariesToLines(boundaries, lineCount, totalDurationSec) {
      if (!Array.isArray(boundaries) || boundaries.length < 3 || !lineCount) {
        return [];
      }
      // Resample boundaries uniformly to lineCount+1
      const out = [0];
      for (let i = 1; i < lineCount; i++) {
        const pos = (i / lineCount) * totalDurationSec;
        // Snap to nearest boundary to keep phrase edges at silences
        let nearest = boundaries[0];
        let best = Math.abs(nearest - pos);
        for (let j = 1; j < boundaries.length; j++) {
          const d = Math.abs(boundaries[j] - pos);
          if (d < best) { best = d; nearest = boundaries[j]; }
        }
        out.push(Math.max(0, Math.min(totalDurationSec, nearest)));
      }
      out.push(totalDurationSec);
      // Ensure monotonic non-decreasing
      for (let i = 1; i < out.length; i++) {
        if (out[i] < out[i - 1]) out[i] = out[i - 1];
      }
      return out;
    }

    // Real-time synced reveal state
    let revealSync = {
      audioEl: null,
      utterance: null,
      lines: [],
      wordCounts: [],
      cumulative: [],
      totalWords: 0,
      currentIdx: -1,
      lastChangeSec: -Infinity,
      fixedSecondsPerLine: null
    };
    let audioTimeHandler = null;
    let estimateTimer = null;

    function buildRevealState(text) {
      const lines = splitMemoryIntoLines(text);
      const wordCounts = lines.map(l => l.split(/\s+/).filter(Boolean).length || 1);
      const cumulative = [];
      let sum = 0;
      for (const c of wordCounts) { sum += c; cumulative.push(sum); }
      revealSync.lines = lines;
      revealSync.wordCounts = wordCounts;
      revealSync.cumulative = cumulative;
      revealSync.totalWords = sum || lines.length;
      revealSync.currentIdx = -1;
    }

    function setCaptionIndex(idx) {
      const caption = document.getElementById('reveal-caption');
      if (!caption) return;
      if (idx === revealSync.currentIdx) return;
      const safeIdx = Math.max(0, Math.min(idx, revealSync.lines.length - 1));
      revealSync.currentIdx = safeIdx;
      const el = document.createElement('div');
      el.className = 'reveal-line';
      el.textContent = revealSync.lines[safeIdx] || '';
      caption.innerHTML = '';
      caption.appendChild(el);
      requestAnimationFrame(() => el.classList.add('show'));
      if (revealSync.audioEl && Number.isFinite(revealSync.audioEl.currentTime)) {
        revealSync.lastChangeSec = revealSync.audioEl.currentTime;
      }
    }

    function setCaptionByWords(wordsSpoken) {
      if (revealSync.totalWords <= 0) return;
      let i = 0;
      while (i < revealSync.cumulative.length && revealSync.cumulative[i] <= wordsSpoken) i++;
      setCaptionIndex(i);
    }

    function setCaptionByTime(currentTimeSec) {
      const boundaries = revealSync.boundaryTimes;
      if (!Array.isArray(boundaries) || boundaries.length === 0) return;
      let idx = 0;
      const hysteresis = 0.12;
      while (idx + 1 < boundaries.length && currentTimeSec >= (boundaries[idx + 1] + hysteresis)) idx++;
      const MIN_SENTENCE_SEC = 2.4;
      if (idx > revealSync.currentIdx && (currentTimeSec - revealSync.lastChangeSec) < MIN_SENTENCE_SEC) {
        return;
      }
      setCaptionIndex(idx);
    }

    function cleanupRevealHandlers() {
      if (revealSync.audioEl && audioTimeHandler) {
        revealSync.audioEl.removeEventListener('timeupdate', audioTimeHandler);
      }
      audioTimeHandler = null;
      if (estimateTimer) {
        clearInterval(estimateTimer);
        estimateTimer = null;
      }
    }

    function startKenBurnsReveal(memoryText, audioEl, utterance, boundaryTimes) {
      try {
        const overlay = document.getElementById('reveal-overlay');
        const caption = document.getElementById('reveal-caption');
        const bg = document.getElementById('reveal-bg');
        const paragraph = document.getElementById('memory-text');
        if (!overlay || !caption || !bg) return;

        overlay.classList.add('active');
        caption.innerHTML = '';
        if (paragraph) paragraph.classList.add('hidden-during-reveal');
        cleanupRevealHandlers();

        // Build state
        buildRevealState(memoryText);
        if (revealSync.fixedSecondsPerLine) {
          const n = revealSync.lines.length;
          revealSync.boundaryTimes = Array.from({ length: n + 1 }, (_, i) => i * revealSync.fixedSecondsPerLine);
        } else {
          revealSync.boundaryTimes = Array.isArray(boundaryTimes) ? boundaryTimes : [];
        }
        if (!revealSync.lines.length) return;
        setCaptionIndex(0);

        // Duration for Ken Burns
        const words = revealSync.totalWords;
        // Fallback pacing tuned for TTS speed=1.0 (~0.6s/word to avoid outpacing)
        const fallbackSec = Math.min(300, Math.max(8, Math.round(words * 0.6)));
        const durSec = (audioEl && Number.isFinite(audioEl.duration) && audioEl.duration > 0)
          ? Math.max(8, Math.min(240, audioEl.duration))
          : fallbackSec;
        bg.style.animationDuration = Math.floor(durSec) + 's';

        // Attach sync via audio time
        revealSync.audioEl = audioEl || null;
        if (audioEl && Number.isFinite(audioEl.duration) && audioEl.duration > 0) {
          audioTimeHandler = () => {
            if (!audioEl.duration || audioEl.duration <= 0) return;
            if (Array.isArray(revealSync.boundaryTimes) && revealSync.boundaryTimes.length) {
              if (revealSync.fixedSecondsPerLine) {
                const idx = Math.min(revealSync.lines.length - 1, Math.floor(audioEl.currentTime / revealSync.fixedSecondsPerLine));
                setCaptionIndex(idx);
              } else {
                setCaptionByTime(audioEl.currentTime);
              }
            } else {
              const progress = Math.max(0, Math.min(1, audioEl.currentTime / audioEl.duration));
              const wordsSpoken = Math.floor(progress * revealSync.totalWords);
              setCaptionByWords(wordsSpoken);
            }
          };
          audioEl.addEventListener('timeupdate', audioTimeHandler);
        } else {
          // Fallback estimated timer when no audio duration
        const wordsPerSec = revealSync.fixedSecondsPerLine
          ? (revealSync.totalWords / (revealSync.lines.length * revealSync.fixedSecondsPerLine))
          : (revealSync.totalWords / fallbackSec);
          let startTs = performance.now();
          estimateTimer = setInterval(() => {
            const elapsedSec = (performance.now() - startTs) / 1000;
            if (Array.isArray(revealSync.boundaryTimes) && revealSync.boundaryTimes.length) {
              if (revealSync.fixedSecondsPerLine) {
                const idx = Math.min(revealSync.lines.length - 1, Math.floor(elapsedSec / revealSync.fixedSecondsPerLine));
                setCaptionIndex(idx);
              } else {
                setCaptionByTime(elapsedSec);
              }
            } else {
              const wordsSpoken = Math.floor(elapsedSec * wordsPerSec);
              setCaptionByWords(wordsSpoken);
            }
          }, 100);
        }

        // Web Speech boundary sync
        revealSync.utterance = utterance || null;
        if (utterance) {
          utterance.onboundary = (event) => {
            try {
              const upto = (event.charIndex || 0);
              const wordsSpoken = memoryText.slice(0, upto).trim().split(/\s+/).filter(Boolean).length;
              setCaptionByWords(wordsSpoken);
            } catch (_) {}
          };
        }
      } catch (e) {
        console.warn('Reveal overlay error:', e);
      }
    }

    function stopKenBurnsReveal() {
      cleanupRevealHandlers();
      const overlay = document.getElementById('reveal-overlay');
      const caption = document.getElementById('reveal-caption');
      const paragraph = document.getElementById('memory-text');
      if (overlay) overlay.classList.remove('active');
      if (caption) caption.innerHTML = '';
      if (paragraph) paragraph.classList.remove('hidden-during-reveal');
      // reset state
      revealSync = { audioEl: null, utterance: null, lines: [], wordCounts: [], cumulative: [], totalWords: 0, currentIdx: -1, lastChangeSec: -Infinity };
    }
  </script>
</body>
</html> 